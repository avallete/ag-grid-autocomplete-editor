{"version":3,"sources":["webpack://ag-grid-autocomplete-editor/webpack/universalModuleDefinition","webpack://ag-grid-autocomplete-editor/./ag-grid-autocomplete-editor.ts","webpack://ag-grid-autocomplete-editor/./autocompleter/autocomplete.ts","webpack://ag-grid-autocomplete-editor/external \"@ag-grid-community/core\"","webpack://ag-grid-autocomplete-editor/webpack/bootstrap","webpack://ag-grid-autocomplete-editor/webpack/startup","webpack://ag-grid-autocomplete-editor/webpack/runtime/define property getters","webpack://ag-grid-autocomplete-editor/webpack/runtime/hasOwnProperty shorthand","webpack://ag-grid-autocomplete-editor/webpack/runtime/make namespace object"],"names":["root","factory","exports","module","require","define","amd","a","i","self","__WEBPACK_EXTERNAL_MODULE__801__","focusAfterAttached","required","eInput","getGui","querySelector","currentItem","value","label","suppressKeyboardEvent","params","keyCode","event","editing","getStartValue","keyPress","charPress","formatValue","init","this","stopEditing","defaultSettings","showOnFocus","render","cellEditor","item","itemElement","document","createElement","escapedValue","replace","regex","RegExp","fieldItem","innerHTML","match","appendChild","addManagedListener","stopPropagation","renderGroup","name","div","textContent","className","minLength","emptyMsg","strict","autoselectfirst","onFreeTextSelect","onSelect","fetch","text","callback","items","getSelectData","toLowerCase","filter","n","indexOf","debounceWaitMs","customize","input","inputRect","container","maxHeight","style","top","bottom","window","innerHeight","offsetHeight","cellStartedEdit","placeholder","AutocompleteSelectCellEditor","autocompleteParams","autocomplete","autocompleter","settings","selected","debounceTimer","doc","ownerDocument","containerStyle","userAgent","navigator","mobileFirefox","keyUpEventName","inputValue","minLen","undefined","keypressCounter","Error","clearDebounceTimer","clearTimeout","containerDisplayed","parentNode","clear","parent","removeChild","update","firstChild","currentValue","groupName","groupDiv","fragment","createDocumentFragment","prevGroup","forEach","group","addEventListener","ev","preventDefault","length","empty","body","height","width","offsetWidth","getBoundingClientRect","defaultView","left","updatePosition","elements","getElementsByClassName","element","previous","previousElementSibling","offsetTop","scrollTop","selectBottom","containerBottom","updateScroll","updateIfDisplayed","resizeEventHandler","scrollEventHandler","e","target","keyupEventHandler","which","startFetch","keydownEventHandler","containerIsDisplayed","selectPrev","selectNext","freeTextSelect","focusEventHandler","trigger","savedKeypressCounter","val","setTimeout","blurEventHandler","activeElement","position","destroy","removeEventListener","result","KeyboardEvent","handleTabEvent","colDef","gridOptionsWrapper","shiftKey","getApi","tabToPreviousCell","tabToNextCell","afterGuiAttached","focus","select","setSelectionRange","focusIn","focusOut","blur","getValue","isCancelAfterEnd","isCancelBeforeStart","isPopup","selectData","Array","isArray","PopupComponent","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag"],"mappings":"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","file":"ag-grid-autocomplete-editor.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@ag-grid-community/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"@ag-grid-community/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"@ag-grid-community/core\")) : factory(root[\"@ag-grid-community/core\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, function(__WEBPACK_EXTERNAL_MODULE__801__) {\nreturn ","import {\n    IAfterGuiAttachedParams,\n    ICellEditorComp,\n    ICellEditorParams,\n    PopupComponent,\n    SuppressKeyboardEventParams\n} from '@ag-grid-community/core';\n\nimport './ag-grid-autocomplete-editor.scss';\n// This import must be done with require because of TypeScript transpiler problems with export default\nimport autocomplete, {AutocompleteItem, EventTrigger} from './autocompleter/autocomplete';\n\n\nconst KEY_BACKSPACE = 8;\nconst KEY_DELETE = 46;\nconst KEY_ENTER = 13;\nconst KEY_TAB = 9;\nconst KEY_UP = 38;\nconst KEY_DOWN = 40;\n\nexport interface DataFormat extends AutocompleteItem {\n    value: number | string;\n    label: string;\n    group?: string;\n}\n\nexport type AutocompleteClient = DataFormat & AutocompleteItem;\n\ninterface IDefaultAutocompleterSettings<T extends AutocompleteItem> {\n    render: (cellEditor: AutocompleteSelectCellEditor, item: T, currentValue: string) => HTMLDivElement | undefined;\n    renderGroup: (cellEditor: AutocompleteSelectCellEditor, name: string, currentValue: string) => HTMLDivElement | undefined;\n    className: string;\n    minLength: number;\n    emptyMsg: string;\n    strict: boolean;\n    autoselectfirst: boolean;\n    onFreeTextSelect: (cellEditor: AutocompleteSelectCellEditor, item: T, input: HTMLInputElement) => void;\n    onSelect: (cellEditor: AutocompleteSelectCellEditor, item: T | undefined, input: HTMLInputElement) => void;\n    fetch: (cellEditor: AutocompleteSelectCellEditor, text: string, update: (items: T[] | false) => void, trigger?: EventTrigger) => void;\n    debounceWaitMs: number;\n    showOnFocus: boolean;\n    customize: (cellEditor: AutocompleteSelectCellEditor, input: HTMLInputElement, inputRect: ClientRect | DOMRect, container: HTMLDivElement, maxHeight: number) => void;\n}\n\nexport interface IAutocompleterSettings<T extends AutocompleteItem> {\n    render?: (cellEditor: AutocompleteSelectCellEditor, item: T, currentValue: string) => HTMLDivElement | undefined;\n    renderGroup?: (cellEditor: AutocompleteSelectCellEditor, name: string, currentValue: string) => HTMLDivElement | undefined;\n    className?: string;\n    minLength?: number;\n    emptyMsg?: string;\n    strict?: boolean;\n    autoselectfirst?: boolean;\n    onFreeTextSelect?: (cellEditor: AutocompleteSelectCellEditor, item: T, input: HTMLInputElement) => void;\n    onSelect?: (cellEditor: AutocompleteSelectCellEditor, item: T | undefined, input: HTMLInputElement) => void;\n    fetch?: (cellEditor: AutocompleteSelectCellEditor, text: string, update: (items: T[] | false) => void, trigger?: EventTrigger) => void;\n    debounceWaitMs?: number;\n    customize?: (cellEditor: AutocompleteSelectCellEditor, input: HTMLInputElement, inputRect: ClientRect | DOMRect, container: HTMLDivElement, maxHeight: number) => void;\n}\n\nexport interface IAutocompleteSelectCellEditorParams extends ICellEditorParams {\n    autocomplete?: IAutocompleterSettings<AutocompleteClient>;\n    selectData: Array<DataFormat> | ((params: IAutocompleteSelectCellEditorParams) => Array<DataFormat>);\n    placeholder?: string;\n    required?: boolean;\n}\n\nexport class AutocompleteSelectCellEditor extends PopupComponent implements ICellEditorComp {\n    public currentItem?: DataFormat;\n    private focusAfterAttached: boolean = false;\n    private readonly eInput: HTMLInputElement;\n    private autocompleter?: any;\n    private required: boolean = false;\n    private stopEditing?: (cancel?: boolean) => void;\n\n    constructor() {\n        super('<div class=\"ag-wrapper ag-input-wrapper ag-text-field-input-wrapper ag-cell-editor-autocomplete-wrapper\" style=\"padding: 0 !important;\"><input class=\"ag-input-field-input ag-text-field-input ag-cell-editor-autocomplete-input\" type=\"text\"/></div>');\n        this.eInput = this.getGui().querySelector('input') as HTMLInputElement;\n        if (this.currentItem) {\n            this.eInput.value = this.currentItem.label || this.currentItem.value as string;\n        }\n    }\n\n    private static suppressKeyboardEvent(params: SuppressKeyboardEventParams): boolean {\n        let keyCode = params.event.keyCode;\n        return params.editing && (keyCode === KEY_UP || keyCode === KEY_DOWN || keyCode === KEY_ENTER || keyCode === KEY_TAB);\n    }\n\n    private static getStartValue(params: IAutocompleteSelectCellEditorParams) {\n        const keyPressBackspaceOrDelete = params.keyPress === KEY_BACKSPACE || params.keyPress === KEY_DELETE;\n        if (keyPressBackspaceOrDelete) {\n            return '';\n        } else if (params.charPress) {\n            return params.charPress;\n        }\n        return params.formatValue(params.value);\n    }\n\n    public init(params: IAutocompleteSelectCellEditorParams) {\n        this.stopEditing = params.stopEditing;\n        const defaultSettings: IDefaultAutocompleterSettings<AutocompleteClient> = {\n            showOnFocus: false,\n            render: function (cellEditor: AutocompleteSelectCellEditor, item: AutocompleteClient, value) {\n                let itemElement = document.createElement(\"div\");\n                let escapedValue = (value ?? '').replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n                let regex = new RegExp(escapedValue, 'gi');\n                let fieldItem = document.createElement('span');\n                fieldItem.innerHTML = item.label.replace(regex, function (match: string) {\n                    return \"<strong>\" + match + \"</strong>\"\n                });\n                itemElement.appendChild(fieldItem);\n                cellEditor.addManagedListener(itemElement, 'mousedown', (event: MouseEvent) => {\n                    cellEditor.currentItem = item;\n                    event.stopPropagation();\n                });\n                return itemElement;\n            },\n            renderGroup: function (cellEditor, name) {\n                let div = document.createElement('div');\n                div.textContent = name;\n                div.className = \"group\";\n                return div;\n            },\n            className: 'ag-cell-editor-autocomplete',\n            minLength: 1,\n            emptyMsg: \"None\",\n            strict: true,\n            autoselectfirst: true,\n            onFreeTextSelect: function () {\n            },\n            onSelect: function (cellEditor, item: AutocompleteClient | undefined) {\n                cellEditor.currentItem = item;\n            },\n            fetch: (cellEditor, text, callback) => {\n                let items = this.getSelectData(params);\n                let match = text.toLowerCase() || cellEditor.eInput.value.toLowerCase();\n                callback(items.filter(function (n) {\n                    return n.label.toLowerCase().indexOf(match) !== -1;\n                }));\n            },\n            debounceWaitMs: 200,\n            customize: function (cellEditor, input, inputRect, container, maxHeight) {\n                if (maxHeight < 100) {\n                    container.style.top = \"10px\";\n                    container.style.bottom = (window.innerHeight - inputRect.bottom + input.offsetHeight) + \"px\";\n                    container.style.maxHeight = \"140px\";\n                }\n            }\n        };\n        this.focusAfterAttached = params.cellStartedEdit;\n\n        this.eInput.placeholder = params.placeholder || '';\n        this.eInput.value = AutocompleteSelectCellEditor.getStartValue(params);\n\n        const autocompleteParams = {...defaultSettings, ...params.autocomplete};\n\n        this.autocompleter = autocomplete({\n            input: this.eInput,\n            render: (item: AutocompleteClient, currentValue: string) => {\n                if (autocompleteParams.render) {\n                    return autocompleteParams.render(this, item, currentValue);\n                }\n                return defaultSettings.render(this, item, currentValue);\n            },\n            renderGroup: (name: string, currentValue: string) => {\n                if (autocompleteParams.renderGroup) {\n                    return autocompleteParams.renderGroup(this, name, currentValue);\n                }\n                return defaultSettings.renderGroup(this, name, currentValue);\n            },\n            className: autocompleteParams.className || defaultSettings.className,\n            minLength: autocompleteParams.minLength !== undefined ? autocompleteParams.minLength : defaultSettings.minLength,\n            emptyMsg: autocompleteParams.emptyMsg || defaultSettings.emptyMsg,\n            strict: autocompleteParams.strict,\n            autoselectfirst: autocompleteParams.autoselectfirst,\n            showOnFocus: autocompleteParams.showOnFocus,\n            onFreeTextSelect: (item: AutocompleteClient, input: HTMLInputElement) => {\n                if (autocompleteParams.onFreeTextSelect) {\n                    return autocompleteParams.onFreeTextSelect(this, item, input);\n                }\n                return defaultSettings.onFreeTextSelect(this, item, input);\n            },\n            onSelect: (item: AutocompleteClient | undefined, input: HTMLInputElement, event: KeyboardEvent | MouseEvent) => {\n                let result: any;\n                if (autocompleteParams.onSelect) {\n                    result = autocompleteParams.onSelect(this, item, input);\n                    if (event instanceof KeyboardEvent) {\n                        this.handleTabEvent(event);\n                    } else {\n                        this.destroy();\n                    }\n                    return result;\n                }\n                result = defaultSettings.onSelect(this, item, input);\n                if (event instanceof KeyboardEvent) {\n                    this.handleTabEvent(event);\n                } else {\n                    this.destroy();\n                }\n                return result;\n            },\n            fetch: (text: string, update: (items: AutocompleteClient[] | false) => void, trigger: EventTrigger) => {\n                if (autocompleteParams.fetch) {\n                    return autocompleteParams.fetch(this, text, update, trigger)\n                }\n                return defaultSettings.fetch(this, text, update, trigger);\n            },\n            debounceWaitMs: autocompleteParams.debounceWaitMs || defaultSettings.debounceWaitMs,\n            customize: (input: HTMLInputElement, inputRect: ClientRect | DOMRect, container: HTMLDivElement, maxHeight: number) => {\n                if (autocompleteParams.customize) {\n                    return autocompleteParams.customize(this, input, inputRect, container, maxHeight);\n                }\n                return defaultSettings.customize(this, input, inputRect, container, maxHeight);\n            }\n        });\n        if (params.required) {\n            this.required = true;\n        }\n        if (!params.colDef.suppressKeyboardEvent) {\n            params.colDef.suppressKeyboardEvent = AutocompleteSelectCellEditor.suppressKeyboardEvent;\n        }\n    }\n\n    handleTabEvent(event: KeyboardEvent) {\n        const keyCode = event.which || event.keyCode || 0;\n        if (keyCode === KEY_TAB && this.gridOptionsWrapper) {\n            if (event.shiftKey) {\n                this.gridOptionsWrapper.getApi()!.tabToPreviousCell();\n            } else {\n                this.gridOptionsWrapper.getApi()!.tabToNextCell();\n            }\n        } else {\n            this.destroy();\n        }\n    }\n\n    afterGuiAttached(params?: IAfterGuiAttachedParams): void {\n        if (!this.focusAfterAttached) {\n            return;\n        }\n\n        const eInput = this.eInput;\n        eInput.focus();\n        eInput.select();\n        // when we started editing, we want the caret at the end, not the start.\n        // this comes into play in two scenarios: a) when user hits F2 and b)\n        // when user hits a printable character, then on IE (and only IE) the caret\n        // was placed after the first character, thus 'apply' would end up as 'pplea'\n        const length = eInput.value ? eInput.value.length : 0;\n        if (length > 0) {\n            eInput.setSelectionRange(length, length);\n        }\n    }\n\n    focusIn(): void {\n        this.eInput.focus();\n        this.eInput.select();\n    }\n\n    focusOut(): void {\n        this.eInput.blur();\n        this.autocompleter.destroy();\n    }\n\n    destroy(): void {\n        this.focusOut();\n        if (this.stopEditing) {\n            this.stopEditing();\n        }\n    }\n\n    getValue(): DataFormat | undefined {\n        return this.currentItem;\n    }\n\n    isCancelAfterEnd(): boolean {\n        if (this.required) {\n            return !this.currentItem;\n        }\n        return false;\n    }\n\n    isCancelBeforeStart(): boolean {\n        return false;\n    }\n\n    isPopup(): boolean {\n        return false;\n    }\n\n    getSelectData(params: IAutocompleteSelectCellEditorParams): Array<DataFormat> {\n        if (typeof params.selectData === 'function') {\n            return params.selectData(params);\n        }\n\n        if (Array.isArray(params.selectData)) {\n            return params.selectData as Array<DataFormat>;\n        }\n\n        return [];\n    }\n}\n","/*\n * https://github.com/kraaden/autocomplete\n * Copyright (c) 2016 Denys Krasnoshchok\n * MIT License\n */\n\nexport const enum EventTrigger {\n    Keyboard = 0,\n    Focus = 1\n}\n\nexport interface AutocompleteItem {\n    label?: string;\n    group?: string;\n}\n\nexport interface AutocompleteSettings<T extends AutocompleteItem> {\n    input: HTMLInputElement;\n    render?: (item: T, currentValue: string) => HTMLDivElement | undefined;\n    renderGroup?: (name: string, currentValue: string) => HTMLDivElement | undefined;\n    className?: string;\n    minLength?: number;\n    emptyMsg?: string;\n    strict: boolean;\n    autoselectfirst: boolean;\n    onFreeTextSelect?: (item: T, input: HTMLInputElement) => void;\n    onSelect: (item: T | undefined, input: HTMLInputElement, event: KeyboardEvent | MouseEvent) => void;\n    /**\n     * Show autocomplete on focus event. Focus event will ignore the `minLength` property and will always call `fetch`.\n     */\n    showOnFocus?: boolean;\n    fetch: (text: string, update: (items: T[] | false) => void, trigger: EventTrigger) => void;\n    debounceWaitMs?: number;\n    /**\n     * Callback for additional autocomplete customization\n     * @param {HTMLInputElement} input - input box associated with autocomplete\n     * @param {ClientRect | DOMRect} inputRect - size of the input box and its position relative to the viewport\n     * @param {HTMLDivElement} container - container with suggestions\n     * @param {number} maxHeight - max height that can be used by autocomplete\n     */\n    customize?: (input: HTMLInputElement, inputRect: ClientRect | DOMRect, container: HTMLDivElement, maxHeight: number) => void;\n}\n\nexport interface AutocompleteResult {\n    destroy: () => void;\n}\n\nconst enum Keys {\n    Enter = 13,\n    Esc = 27,\n    Up = 38,\n    Down = 40,\n    Left = 37,\n    Right = 39,\n    Shift = 16,\n    Ctrl = 17,\n    Alt = 18,\n    CapsLock = 20,\n    WindowsKey = 91,\n    Tab = 9\n}\n\nexport default function autocomplete<T extends AutocompleteItem>(this: any, settings: AutocompleteSettings<T>): AutocompleteResult {\n\n    // just an alias to minimize JS file size\n    // use settings.input.ownerDocument if possible, to avoid iFrame scopes confusion\n    let doc = settings.input.ownerDocument || window.document;\n    const container: HTMLDivElement = doc.createElement(\"div\");\n    const containerStyle = container.style;\n    const userAgent = navigator.userAgent;\n    const mobileFirefox = userAgent.indexOf(\"Firefox\") !== -1 && userAgent.indexOf(\"Mobile\") !== -1;\n    const debounceWaitMs = settings.debounceWaitMs || 0;\n    const strict = settings.strict;\n    const autoselectfirst = settings.autoselectfirst;\n    const onFreeTextSelect = settings.onFreeTextSelect;\n\n    // 'keyup' event will not be fired on Mobile Firefox, so we have to use 'input' event instead\n    const keyUpEventName = mobileFirefox ? \"input\" : \"keyup\";\n\n    let items: T[] = [];\n    let inputValue = \"\";\n    const minLen = settings.minLength !== undefined ? settings.minLength : 2;\n    const showOnFocus = settings.showOnFocus;\n    let selected: T | undefined;\n    let keypressCounter = 0;\n    let debounceTimer: number | undefined;\n\n    if (!settings.input) {\n        throw new Error(\"input undefined\");\n    }\n\n    const input: HTMLInputElement = settings.input;\n\n    container.className = \"autocomplete \" + (settings.className || \"\");\n    containerStyle.position = \"fixed\";\n\n    /**\n     * Detach the container from DOM\n     */\n    function detach(): void {\n        const parent = container.parentNode;\n        if (parent) {\n            parent.removeChild(container);\n        }\n    }\n\n    /**\n     * Clear debouncing timer if assigned\n     */\n    function clearDebounceTimer(): void {\n        if (debounceTimer) {\n            window.clearTimeout(debounceTimer);\n        }\n    }\n\n    /**\n     * Attach the container to DOM\n     */\n    function attach(): void {\n        doc = settings.input.ownerDocument || window.document;\n        if (!container.parentNode) {\n            doc.body.appendChild(container);\n        }\n    }\n\n    /**\n     * Check if container for autocomplete is displayed\n     */\n\n    function containerDisplayed(): boolean {\n        return !!container.parentNode;\n    }\n\n    /**\n     * Clear autocomplete state and hide container\n     */\n\n    function clear(): void {\n        keypressCounter++;\n        items = [];\n        inputValue = \"\";\n        selected = undefined;\n        detach();\n    }\n\n    /**\n     * Update autocomplete position\n     */\n    function updatePosition(): void {\n        if (!containerDisplayed()) {\n            return;\n        }\n\n        containerStyle.height = \"auto\";\n        containerStyle.width = input.offsetWidth + \"px\";\n\n        const inputRect = input.getBoundingClientRect();\n        const top = inputRect.top + input.offsetHeight;\n        let maxHeight = doc.defaultView!.innerHeight - top;\n\n        if (maxHeight < 0) {\n            maxHeight = 0;\n        }\n\n        containerStyle.top = top + \"px\";\n        containerStyle.bottom = \"\";\n        containerStyle.left = inputRect.left + \"px\";\n        containerStyle.maxHeight = maxHeight + \"px\";\n\n        if (settings.customize) {\n            settings.customize(input, inputRect, container, maxHeight);\n        }\n    }\n\n    /**\n     * Redraw the autocomplete div element with suggestions\n     */\n\n    function update(): void {\n\n        // delete all children from autocomplete DOM container\n        while (container.firstChild) {\n            container.removeChild(container.firstChild);\n        }\n\n        // function for rendering autocomplete suggestions\n        // noinspection JSUnusedLocalSymbols\n        let render = function (item: T, currentValue: string): HTMLDivElement | undefined {\n            const itemElement = doc.createElement(\"div\");\n            itemElement.textContent = item.label || \"\";\n            return itemElement;\n        };\n        if (settings.render) {\n            render = settings.render;\n        }\n\n        // function to render autocomplete groups\n        // noinspection JSUnusedLocalSymbols\n        let renderGroup = function (groupName: string, currentValue: string): HTMLDivElement | undefined {\n            const groupDiv = doc.createElement(\"div\");\n            groupDiv.textContent = groupName;\n            return groupDiv;\n        };\n        if (settings.renderGroup) {\n            renderGroup = settings.renderGroup;\n        }\n\n        const fragment = doc.createDocumentFragment();\n        let prevGroup = \"#9?$\";\n\n        items.forEach(function (item: T): void {\n            if (item.group && item.group !== prevGroup) {\n                prevGroup = item.group;\n                const groupDiv = renderGroup(item.group, inputValue);\n                if (groupDiv) {\n                    groupDiv.className += \" group\";\n                    fragment.appendChild(groupDiv);\n                }\n            }\n            const div = render(item, inputValue);\n            if (div) {\n                div.addEventListener(\"click\", function (ev: MouseEvent): void {\n                    settings.onSelect(item, input, ev);\n                    clear();\n                    ev.preventDefault();\n                    ev.stopPropagation();\n                });\n                if (item === selected) {\n                    div.className += \" selected\";\n                }\n                fragment.appendChild(div);\n            }\n        });\n        container.appendChild(fragment);\n        if (items.length < 1 && strict) {\n            if (settings.emptyMsg) {\n                const empty = doc.createElement(\"div\");\n                empty.className = \"empty\";\n                empty.textContent = settings.emptyMsg;\n                container.appendChild(empty);\n                selected = undefined;\n            } else {\n                clear();\n                return;\n            }\n        }\n\n        attach();\n        updatePosition();\n\n        updateScroll();\n    }\n\n    function updateIfDisplayed(): void {\n        if (containerDisplayed()) {\n            update();\n        }\n    }\n\n    function resizeEventHandler(): void {\n        updateIfDisplayed();\n    }\n\n    function scrollEventHandler(e: Event): void {\n        if (e.target !== container) {\n            updateIfDisplayed();\n        } else {\n            e.preventDefault();\n        }\n    }\n\n    function keyupEventHandler(ev: KeyboardEvent): void {\n        const keyCode = ev.which || ev.keyCode || 0;\n\n        const ignore = [Keys.Up, Keys.Enter, Keys.Esc, Keys.Right, Keys.Left, Keys.Shift, Keys.Ctrl, Keys.Alt, Keys.CapsLock, Keys.WindowsKey, Keys.Tab];\n        for (const key of ignore) {\n            if (keyCode === key) {\n                return;\n            }\n        }\n\n        // the down key is used to open autocomplete\n        if (keyCode === Keys.Down && containerDisplayed()) {\n            return;\n        }\n\n        startFetch(EventTrigger.Keyboard);\n    }\n\n    /**\n     * Automatically move scroll bar if selected item is not visible\n     */\n\n    function updateScroll(): void {\n        const elements = container.getElementsByClassName(\"selected\");\n        if (elements.length > 0) {\n            let element = elements[0] as HTMLDivElement;\n\n            // make group visible\n            const previous = element.previousElementSibling as HTMLDivElement;\n            if (previous && previous.className.indexOf(\"group\") !== -1 && !previous.previousElementSibling) {\n                element = previous;\n            }\n\n            if (element.offsetTop < container.scrollTop) {\n                container.scrollTop = element.offsetTop;\n            } else {\n                const selectBottom = element.offsetTop + element.offsetHeight;\n                const containerBottom = container.scrollTop + container.offsetHeight;\n                if (selectBottom > containerBottom) {\n                    container.scrollTop += selectBottom - containerBottom;\n                }\n            }\n        }\n    }\n\n    /**\n     * Select the previous item in suggestions\n     */\n\n    function selectPrev(): void {\n        if (items.length < 1) {\n            selected = undefined;\n        } else {\n            if (selected === items[0] || selected === undefined) {\n                selected = items[items.length - 1];\n            } else {\n                for (let i = items.length - 1; i > 0; i--) {\n                    if (selected === items[i] || i === 1) {\n                        selected = items[i - 1];\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Select the next item in suggestions\n     */\n\n    function selectNext(): void {\n        if (items.length < 1) {\n            selected = undefined;\n        }\n        if (!selected || selected === items[items.length - 1]) {\n            selected = items[0];\n            return;\n        }\n        for (let i = 0; i < (items.length - 1); i++) {\n            if (selected === items[i]) {\n                selected = items[i + 1];\n                break;\n            }\n        }\n    }\n\n    function keydownEventHandler(ev: KeyboardEvent): void {\n        const keyCode = ev.which || ev.keyCode || 0;\n\n        if (keyCode === Keys.Up || keyCode === Keys.Down || keyCode === Keys.Esc) {\n            const containerIsDisplayed = containerDisplayed();\n\n            if (keyCode === Keys.Esc) {\n                settings.onSelect(undefined, input, ev);\n                clear();\n            } else {\n                if (!containerDisplayed || items.length < 1) {\n                    return;\n                }\n                keyCode === Keys.Up\n                    ? selectPrev()\n                    : selectNext();\n                update();\n            }\n\n            ev.preventDefault();\n            if (containerIsDisplayed) {\n                ev.stopPropagation();\n            }\n\n            return;\n        }\n\n        if (keyCode === Keys.Enter || keyCode === Keys.Tab) {\n            if (strict) {\n                settings.onSelect(selected, input, ev);\n                clear();\n            }\n            if (!strict) {\n                const freeTextSelect = {label: input.value} as T;\n                if (!selected) {\n                    if (onFreeTextSelect) {\n                        onFreeTextSelect(freeTextSelect, input);\n                    }\n                    settings.onSelect(freeTextSelect, input, ev);\n                } else {\n                    settings.onSelect(selected, input, ev);\n                }\n                clear();\n            }\n        }\n    }\n\n    function focusEventHandler(): void {\n        if (showOnFocus) {\n            startFetch(EventTrigger.Focus);\n        }\n    }\n\n    function startFetch(trigger: EventTrigger) {\n        // if multiple keys were pressed, before we get update from server,\n        // this may cause redrawing our autocomplete multiple times after the last key press.\n        // to avoid this, the number of times keyboard was pressed will be\n        // saved and checked before redraw our autocomplete box.\n        const savedKeypressCounter = ++keypressCounter;\n\n        const val = input.value;\n        if (val.length >= minLen || trigger === EventTrigger.Focus) {\n            clearDebounceTimer();\n            debounceTimer = window.setTimeout(function (): void {\n                settings.fetch(val, function (elements: T[] | false): void {\n                    if (keypressCounter === savedKeypressCounter && elements) {\n                        items = elements;\n                        inputValue = val;\n                        selected = items.length > 0 && autoselectfirst ? items[0] : undefined;\n                        update();\n                    }\n                }, EventTrigger.Keyboard);\n            }, trigger === EventTrigger.Keyboard ? debounceWaitMs : 0);\n        } else {\n            clear();\n        }\n    }\n\n    function blurEventHandler(): void {\n        // we need to delay clear, because when we click on an item, blur will be called before click and remove items from DOM\n        setTimeout(() => {\n            if (doc.activeElement !== input) {\n                clear();\n            }\n        }, 200);\n    }\n\n    /**\n     * This function will remove DOM elements and clear event handlers\n     */\n\n    function destroy(): void {\n        input.removeEventListener(\"focus\", focusEventHandler);\n        input.removeEventListener(\"keydown\", keydownEventHandler);\n        input.removeEventListener(keyUpEventName, keyupEventHandler as EventListenerOrEventListenerObject);\n        input.removeEventListener(\"blur\", blurEventHandler);\n        doc.removeEventListener(\"resize\", resizeEventHandler);\n        doc.removeEventListener(\"scroll\", scrollEventHandler, true);\n        clearDebounceTimer();\n        clear();\n\n        // prevent the update call if there are pending AJAX requests\n        keypressCounter++;\n    }\n\n    // setup event handlers\n    input.addEventListener(\"keydown\", keydownEventHandler);\n    input.addEventListener(keyUpEventName, keyupEventHandler as EventListenerOrEventListenerObject);\n    input.addEventListener(\"blur\", blurEventHandler);\n    input.addEventListener(\"focus\", focusEventHandler);\n    doc.addEventListener(\"resize\", resizeEventHandler);\n    doc.addEventListener(\"scroll\", scrollEventHandler, true);\n\n    return {\n        destroy\n    };\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__801__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(220);\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};"],"sourceRoot":""}